# RFP Agent Video Tutorial Scripts

## Tutorial Series Overview

This document contains scripts for a comprehensive video tutorial series covering the RFP Agent platform from basic usage to advanced integrations.

### Series Structure

1. **Getting Started** (5-7 minutes)
2. **RFP Discovery & Management** (8-10 minutes)
3. **AI-Powered Proposal Generation** (10-12 minutes)
4. **Automated Submission** (8-10 minutes)
5. **Agent System & Workflows** (12-15 minutes)
6. **API Integration for Developers** (15-20 minutes)

---

## Video 1: Getting Started with RFP Agent

**Duration:** 5-7 minutes
**Target Audience:** New users, business owners, proposal managers

### Script

**[INTRO - 0:00-0:30]**

"Welcome to RFP Agent - the AI-powered platform that revolutionizes how you discover, respond to, and win government contracts. I'm [Name], and in the next 5 minutes, I'll show you how to get started with RFP Agent and discover your first opportunities.

By the end of this video, you'll know how to:

- Set up your account
- Configure government portals
- Discover your first RFP
- Understand the dashboard

Let's dive in!"

**[ACCOUNT SETUP - 0:30-1:30]**

_[SCREEN: Login page]_

"First, let's log into RFP Agent. If you're a new user, click 'Sign Up' and enter your business details.

_[SCREEN: Registration form]_

You'll need to provide:

- Your company name
- Business email
- Industry category
- NAICS codes

This information helps our AI understand which opportunities are most relevant for your business.

_[SCREEN: Email verification]_

Check your email for a verification link and click it to activate your account."

**[DASHBOARD OVERVIEW - 1:30-2:30]**

_[SCREEN: Main dashboard]_

"Great! Now you're logged in. Let's familiarize ourselves with the dashboard.

On the left sidebar, you'll find:

- **Dashboard** - Your command center
- **RFPs** - All discovered opportunities
- **Proposals** - Generated proposal documents
- **Portals** - Government procurement sites we monitor
- **Submissions** - Track submitted proposals

The main dashboard shows:

- **Active RFPs** - Current opportunities
- **Proposal Status** - Works in progress
- **Portal Activity** - Recent discoveries
- **Win Rate** - Your success metrics"

**[PORTAL CONFIGURATION - 2:30-4:00]**

_[SCREEN: Portals page]_

"Next, let's configure which government portals to monitor. Click 'Portals' in the sidebar.

_[SCREEN: Add Portal button]_

Click 'Add Portal' and you'll see our pre-configured portals:

- SAM.gov for federal contracts
- State portals
- Municipal portals

_[SCREEN: Portal configuration]_

For this demo, let's enable 'City of Austin Finance Online.'

Toggle 'Monitoring Enabled' to ON.

Set scan frequency - I recommend every 24 hours to start.

You can add filters for:

- Business categories
- Minimum contract value
- Keywords to include or exclude

_[CLICK: Save]_

Perfect! RFP Agent will now automatically scan this portal daily."

**[FIRST RFP DISCOVERY - 4:00-5:30]**

_[SCREEN: Portals page, click Scan Now]_

"Let's discover some opportunities right now. Click 'Scan Now' next to Austin portal.

_[SCREEN: Scan progress modal]_

Watch as our AI agents work:

1. Authenticating to the portal
2. Searching for opportunities
3. Extracting RFP details
4. Downloading documents

_[SCREEN: Scan complete notification]_

Great! We found 8 new RFPs. Click 'View Results' to see them.

_[SCREEN: RFP list]_

Here's our first discovery! Let's click on this 'IT Services' RFP.

_[SCREEN: RFP detail page]_

Notice how RFP Agent automatically extracted:

- RFP title and description
- Issuing agency
- Deadline
- Estimated value
- All documents

You can also see our AI's initial analysis highlighting key requirements and compliance items."

**[CALL TO ACTION - 5:30-6:00]**

_[SCREEN: Dashboard with new RFPs]_

"And that's it! In just a few minutes, you've:
✓ Set up your account
✓ Configured portal monitoring
✓ Discovered real RFP opportunities

In our next video, I'll show you how to use RFP Agent's AI to generate winning proposals automatically.

Don't forget to subscribe and click the bell icon for notifications. See you in the next tutorial!"

**[END SCREEN - 6:00]**

---

## Video 2: RFP Discovery & Management

**Duration:** 8-10 minutes
**Target Audience:** Users familiar with basics, ready to optimize discovery

### Script

**[INTRO - 0:00-0:30]**

"Welcome back to RFP Agent Academy! In this video, we'll dive deep into RFP discovery and management. You'll learn how to:

- Configure advanced portal filters
- Manually add RFPs from any website
- Organize and prioritize opportunities
- Use AI chat to find specific RFPs

Let's get started!"

**[ADVANCED PORTAL FILTERS - 0:30-2:30]**

_[SCREEN: Portal settings]_

"Smart filtering is key to finding the right opportunities. Let's configure advanced filters for maximum relevance.

_[SCREEN: Portal edit modal]_

Click 'Edit' on the Austin portal. Here's how to set up powerful filters:

**Value Filters:**
Set minimum value to $50,000 - this filters out smaller contracts.
Set maximum if you have capacity limits - say $5 million.

**Business Category Filters:**
_[SCREEN: Category selection]_

Select your expertise areas. For a tech company, choose:

- Information Technology
- Software Development
- Cloud Services
- Cybersecurity

**Keyword Filters:**
_[SCREEN: Keyword input]_

INCLUDE keywords like:

- 'cloud migration'
- 'application development'
- 'digital transformation'

EXCLUDE keywords to avoid irrelevant RFPs:

- 'construction'
- 'janitorial'
- 'lawn maintenance'

_[CLICK: Save]_

Now RFP Agent will only show you highly relevant opportunities!"

**[MANUAL RFP ADDITION - 2:30-4:30]**

_[SCREEN: RFP list page]_

"Sometimes you'll find an RFP on a portal we don't monitor yet. No problem! RFP Agent can process any RFP URL.

_[SCREEN: Click 'Add RFP' button]_

Click 'Add RFP' in the top right.

_[SCREEN: Manual RFP form]_

Paste the RFP URL - I'll use this Philadelphia contract:
<https://phlcontracts.phila.gov/contract/123456>

Add notes if needed - 'High priority, existing client relationship.'

_[CLICK: Submit]_

Watch the magic happen:

_[SCREEN: Processing progress]_

1. **Scraping** - Our AI navigates the portal
2. **Extracting** - Pulls RFP details automatically
3. **Document Discovery** - Finds all attachments
4. **Downloading** - Saves documents to your library
5. **Analysis** - AI analyzes requirements

_[SCREEN: Completed RFP detail]_

In 30 seconds, RFP Agent has:

- Created the RFP record
- Downloaded 5 PDF documents
- Extracted key dates and requirements
- Identified compliance needs

You just saved 2 hours of manual work!"

**[RFP ORGANIZATION - 4:30-6:30]**

_[SCREEN: RFP list with filters]_

"As opportunities pile up, organization is crucial. Let's explore RFP Agent's management tools.

**Status-Based Organization:**
_[SCREEN: Status filter dropdown]_

RFPs move through these stages:

- **Discovered** - Just found
- **Parsing** - Documents being analyzed
- **Drafting** - Proposal in progress
- **Review** - Awaiting approval
- **Approved** - Ready to submit
- **Submitted** - Sent to agency
- **Closed** - Complete

Filter by status to focus your work.

**Priority Sorting:**
_[SCREEN: Sort options]_

Sort by:

- **Deadline** - Most urgent first
- **Value** - Highest revenue opportunities
- **Match Score** - Best fit for your capabilities

**Bulk Actions:**
_[SCREEN: Select multiple RFPs]_

Select multiple RFPs to:

- Generate proposals in batch
- Export to spreadsheet
- Archive older opportunities

This is perfect for proposal managers handling many RFPs!"

**[AI CHAT FOR RFP DISCOVERY - 6:30-8:30]**

_[SCREEN: AI Chat icon in top right]_

"Here's a powerful feature: AI Chat. Click the chat icon.

_[SCREEN: Chat interface]_

Instead of filtering manually, just ask:

_[TYPE: 'Find me cloud infrastructure RFPs from Austin worth over $200k']_

_[SCREEN: AI response with results]_

The AI instantly shows 3 matching RFPs with:

- Summaries
- Quick actions
- Relevance scores

Let's try something more complex:

_[TYPE: 'Which RFPs have upcoming deadlines this month that match our cybersecurity expertise?']_

_[SCREEN: AI response]_

Amazing! The AI understands:

- Time context ('this month')
- Your company profile ('cybersecurity expertise')
- Urgency (upcoming deadlines)

This is like having a smart assistant who knows every RFP detail!"

**[WRAP UP - 8:30-9:00]**

"Perfect! You now know how to:
✓ Set up advanced portal filters
✓ Add RFPs from any website
✓ Organize opportunities efficiently
✓ Use AI chat for instant discovery

In the next video, we'll generate winning proposals using GPT-5 AI.

Subscribe and hit the notification bell. See you next time!"

**[END SCREEN]**

---

## Video 3: AI-Powered Proposal Generation

**Duration:** 10-12 minutes
**Target Audience:** Users ready to generate proposals

### Script

**[INTRO - 0:00-0:45]**

"Welcome to the most exciting part of RFP Agent - AI-powered proposal generation!

Today, I'll show you how our GPT-5 powered AI creates professional, compliant, winning proposals in minutes, not weeks.

Here's what we'll cover:

- Company profile setup
- Automated proposal generation
- Customization and refinement
- Quality assurance

By the end, you'll generate a complete proposal ready for submission. Let's begin!"

**[COMPANY PROFILE SETUP - 0:45-3:00]**

_[SCREEN: Company Profile page]_

"Before generating proposals, we need your company profile. Click 'Company' in the sidebar.

_[SCREEN: Profile creation form]_

**Basic Information:**

- Company legal name
- DBA (if different)
- Website
- Business category

**Identification:**
_[SCREEN: Identifiers section]_

Add your business identifiers:

- DUNS number
- SAM UEI number
- Tax ID/EIN
- Vendor IDs for each portal

**Certifications:**
_[SCREEN: Certifications section]_

List all certifications:

- Small Business
- Woman-Owned
- HUB (Historically Underutilized Business)
- DBE, MBE, etc.

Our AI uses these to highlight compliance advantages!

**Capabilities:**
_[SCREEN: Capabilities section]_

Detail your expertise:

- Core services
- Technologies
- Industries served
- Geographic coverage
- Team size and specializations

**Past Performance:**
_[SCREEN: Projects section]_

Add relevant projects:

- Client name
- Project description
- Contract value
- Outcomes achieved

The more detail, the better the AI-generated proposals!

_[CLICK: Save Profile]_"

**[PROPOSAL GENERATION - 3:00-6:30]**

_[SCREEN: RFP detail page]_

"Now for the exciting part! Let's generate a proposal for this Cloud Infrastructure RFP.

_[SCREEN: Click 'Generate Proposal' button]_

You'll see generation options:

_[SCREEN: Generation options modal]_

**Proposal Type:**

- Technical Proposal
- Cost Proposal
- Combined (recommended)

**Components to Include:**
☑ Executive Summary
☑ Technical Approach
☑ Company Qualifications
☑ Past Performance
☑ Staffing Plan
☑ Pricing Tables
☑ Compliance Matrix

**Advanced Options:**

- Quality threshold (0-100%)
- Writing style (Professional, Persuasive, Technical)
- Compliance strictness

_[CLICK: Generate]_

Watch the AI work:

_[SCREEN: Generation progress]_

**Phase 1: Document Analysis** (30 seconds)

- Reading all RFP documents
- Extracting requirements
- Identifying evaluation criteria
- Finding compliance mandates

**Phase 2: Content Generation** (2-3 minutes)

- Crafting executive summary
- Developing technical approach
- Matching past performance
- Creating staffing plan

**Phase 3: Compliance Checking** (1 minute)

- Verifying all requirements addressed
- Building compliance matrix
- Flagging any gaps

**Phase 4: Quality Assurance** (30 seconds)

- Checking consistency
- Verifying formatting
- Final polish

_[SCREEN: Generation complete notification]_

Done! Let's review what the AI created."

**[PROPOSAL REVIEW - 6:30-9:00]**

_[SCREEN: Generated proposal view]_

"Here's your AI-generated proposal. Let's explore each section:

**Executive Summary:**
_[SCREEN: Scroll through executive summary]_

Notice how the AI:

- Addresses the agency's specific needs
- Highlights your unique qualifications
- References the RFP by name and number
- Uses persuasive, professional language

**Technical Approach:**
_[SCREEN: Technical approach section]_

The AI created:

- Detailed methodology aligned with requirements
- Phase-by-phase implementation plan
- Risk mitigation strategies
- Success metrics

All derived from your company capabilities and the RFP requirements!

**Past Performance:**
_[SCREEN: Past performance section]_

The AI selected your 3 most relevant projects and wrote compelling narratives showing:

- Similar scope and complexity
- Successful outcomes
- Relevant technologies
- Client satisfaction

**Compliance Matrix:**
_[SCREEN: Compliance matrix]_

This is crucial! The AI built a complete matrix showing:

- Every RFP requirement
- Where it's addressed in your proposal
- Page numbers for easy reference

**Pricing:**
_[SCREEN: Pricing section]_

Based on the scope, the AI created:

- Line item budget
- Labor categories and rates
- Materials and expenses
- Total project cost

You can adjust any numbers before finalizing."

**[CUSTOMIZATION - 9:00-10:30]**

_[SCREEN: Edit mode]_

"While the AI does 90% of the work, you can customize anything. Click 'Edit.'

_[SCREEN: Inline editing]_

You can:

- Modify any text inline
- Add sections
- Reorder content
- Adjust pricing
- Upload additional documents

Let's customize the executive summary:

_[SCREEN: Edit executive summary]_

I'll add our recent industry award:
'Recently recognized as 2024 Cloud Innovation Partner of the Year by TechExcellence Awards.'

_[CLICK: Save]_

You can also regenerate specific sections if needed:

_[SCREEN: Right-click section menu]_

Right-click any section and choose:

- Regenerate with different tone
- Expand with more detail
- Condense for brevity

Let's make the technical approach more detailed:

_[CLICK: Regenerate > More Detail]_

_[SCREEN: AI regenerating section]_

Perfect! The AI expanded it with additional technical specifics."

**[QUALITY ASSURANCE - 10:30-11:30]**

_[SCREEN: Quality check dashboard]_

"Before submitting, run the quality check. Click 'Run Quality Check.'

_[SCREEN: Quality analysis running]_

The AI analyzes:

**Completeness (95/100):**

- All requirements addressed ✓
- All forms included ✓
- Minor: Add one more reference ⚠

**Compliance (100/100):**

- All mandatory items present ✓
- Format requirements met ✓
- Page limits adhered to ✓

**Quality (92/100):**

- Grammar and spelling perfect ✓
- Consistent terminology ✓
- Professional formatting ✓

**Competitiveness (88/100):**

- Strong value proposition ✓
- Competitive pricing ✓
- Good: Quantify more benefits ⚠

_[SCREEN: Recommendations]_

The AI suggests:

1. Add contact reference for XYZ Corp project
2. Quantify cost savings in Executive Summary
3. Emphasize sustainability approach (per RFP section 3.4)

Make these quick improvements and you have a winning proposal!"

**[WRAP UP - 11:30-12:00]**

"Amazing! You just created a comprehensive, compliant proposal in under 10 minutes.

To recap:
✓ Set up your company profile
✓ Generated AI-powered proposal
✓ Customized for your voice
✓ Ran quality assurance

In our next video, I'll show you how to submit this proposal automatically through portal automation.

Subscribe for more RFP Agent tutorials!"

**[END SCREEN]**

---

## Video 4: Automated Submission

**Duration:** 8-10 minutes
**Target Audience:** Users ready to submit proposals

### Script

**[INTRO - 0:00-0:30]**

"Welcome back! You've discovered RFPs and generated amazing proposals. Now comes the final step: submission.

In this video, I'll show you how RFP Agent's automation can submit your proposal to government portals automatically, saving hours of tedious form-filling.

We'll cover:

- Pre-submission checklist
- Portal authentication
- Automated form filling
- Document upload
- Submission verification

Let's automate your way to winning bids!"

**[PRE-SUBMISSION CHECKLIST - 0:30-2:00]**

_[SCREEN: Proposal detail page]_

"Before submitting, ensure everything is ready. RFP Agent provides a smart checklist.

_[SCREEN: Click 'Prepare for Submission']_

**Document Checklist:**
☑ Technical Proposal (PDF) - 42 pages ✓
☑ Cost Proposal (Excel) - Complete ✓
☑ Form A: Vendor Information - Signed ✓
☑ Form B: Non-Collusion Affidavit - Signed ✓
☑ Insurance Certificate - Valid through 2025 ✓
☑ HUB Certification - Current ✓

**Compliance Checklist:**
☑ All requirements addressed ✓
☑ Page limits met (45/50 pages) ✓
☑ File formats correct ✓
☑ Signatures obtained ✓

**Portal Requirements:**
☑ Portal account active ✓
☑ Vendor profile updated ✓
⚠ 2FA code needed for submission

Everything looks good! Let's proceed."

**[PORTAL AUTHENTICATION - 2:00-3:30]**

_[SCREEN: Click 'Submit to Portal']_

"RFP Agent needs to authenticate to the portal on your behalf.

_[SCREEN: Portal credentials form]_

Enter your portal credentials:

- Username: <vendor@example.com>
- Password: ••••••••

_[SCREEN: Security notice]_

Security note: RFP Agent encrypts and securely stores credentials. They're never exposed or shared.

_[CLICK: Authenticate]_

_[SCREEN: 2FA prompt]_

For portals with two-factor authentication, you'll need to verify:

_[SCREEN: Phone notification]_

Check your phone for the 2FA code.

_[ENTER: 2FA code]_

_[SCREEN: Authentication successful]_

Perfect! We're authenticated and ready to submit."

**[AUTOMATED FORM FILLING - 3:30-5:30]**

_[SCREEN: Submission automation dashboard]_

"Now watch as our AI fills out the portal forms automatically.

_[SCREEN: Portal submission page loading]_

The automation begins:

**Step 1: RFP Selection**
_[SCREEN: AI selecting correct RFP]_

The AI navigates to the correct RFP submission page.

**Step 2: Vendor Information**
_[SCREEN: Form auto-filling]_

Watch as the AI fills in:

- Company name
- DUNS number
- Address
- Contact information

All from your company profile - no manual typing!

**Step 3: Proposal Sections**
_[SCREEN: Section-by-section filling]_

The AI fills complex forms:

- Technical approach summary
- Key personnel
- Subcontractors
- Pricing breakdown

Notice how it adapts to different form formats and field types.

**Step 4: Compliance Questions**
_[SCREEN: Checkbox forms]_

The AI intelligently answers compliance questions:
'Are you a small business?' - YES ✓
'HUB certified?' - YES ✓
'Conflict of interest?' - NO ✓

All based on your company profile and RFP requirements."

**[DOCUMENT UPLOAD - 5:30-7:00]**

_[SCREEN: File upload section]_

"Now comes document upload - typically the most tedious part.

**Automated Upload Process:**

_[SCREEN: Upload progress]_

The AI is uploading:

1. Technical_Proposal.pdf → 'Technical Approach' field ✓
2. Cost_Proposal.xlsx → 'Pricing Information' field ✓
3. Form_A_Signed.pdf → 'Vendor Forms' field ✓
4. Insurance_Certificate.pdf → 'Required Documents' field ✓
5. HUB_Certification.pdf → 'Certifications' field ✓

_[SCREEN: Progress bar]_

All 5 documents uploaded in 45 seconds!

**Smart Field Mapping:**

Notice how the AI knew where to upload each document? It analyzed:

- Form field labels
- Document types
- RFP requirements

And matched everything perfectly!"

**[SUBMISSION VERIFICATION - 7:00-8:30]**

_[SCREEN: Final review page]_

"Before final submission, the AI performs verification:

**Completeness Check:**
✓ All required fields completed
✓ All documents attached
✓ All questions answered
✓ No errors or warnings

_[SCREEN: Click 'Final Submit']_

_[SCREEN: Confirmation dialog]_

'Ready to submit? This action cannot be undone.'

_[CLICK: Confirm]_

_[SCREEN: Submission progress]_

Submitting to portal...

_[SCREEN: Success notification]_

**Submission Successful!**

_[SCREEN: Confirmation details]_

Portal confirmation:

- Reference Number: RFP-2024-IT-567
- Submitted: Jan 15, 2024 at 3:42 PM
- Received by: City of Austin Procurement
- Confirmation Email: Sent to <vendor@example.com>

_[SCREEN: Receipt download]_

RFP Agent automatically:
✓ Downloaded submission receipt
✓ Archived all documents
✓ Created audit trail
✓ Set follow-up reminders

You're done!"

**[TRACKING & ANALYTICS - 8:30-9:30]**

_[SCREEN: Submissions dashboard]_

"After submission, track everything in one place:

_[SCREEN: Submission status]_

**Active Submissions:**

- RFP-2024-IT-567: Submitted, awaiting evaluation
- Award notification expected: Feb 15, 2024
- Status checks scheduled: Weekly

**Submission Analytics:**

- Total submitted: 23
- Win rate: 35%
- Average submission time: 8 minutes (vs 4 hours manual)
- Time saved: 92 hours

**Follow-up Actions:**

- Calendar reminders for Q&A deadlines
- Alerts for addendums
- Notifications for award decisions

Everything automated and tracked!"

**[WRAP UP - 9:30-10:00]**

"Incredible! You just submitted a complete proposal in under 10 minutes with:
✓ Automated portal login
✓ AI-powered form filling
✓ Intelligent document upload
✓ Verified submission
✓ Complete audit trail

In our next video, I'll show you the agent system and workflows that power all this automation.

Don't forget to subscribe!"

**[END SCREEN]**

---

## Video 5: Agent System & Workflows

**Duration:** 12-15 minutes
**Target Audience:** Power users, administrators

### Script

**[INTRO - 0:00-0:45]**

"Welcome to the advanced RFP Agent tutorial! Today we're going behind the scenes to explore the 3-tier agent system and workflows.

This is what makes RFP Agent truly intelligent - not just one AI, but a team of 11 specialized AI agents working together.

We'll explore:

- The 3-tier architecture
- Agent coordination
- Custom workflow creation
- Performance monitoring

This knowledge will help you optimize RFP Agent for maximum efficiency. Let's dive into the system!"

**[3-TIER ARCHITECTURE - 0:45-3:00]**

_[SCREEN: Agent system diagram]_

"RFP Agent uses a sophisticated 3-tier hierarchy, inspired by how successful companies organize teams.

**Tier 1: The Orchestrator (1 Agent)**
_[SCREEN: Orchestrator dashboard]_

The Primary Orchestrator is like a CEO:

- Receives your requests
- Plans the strategy
- Delegates to managers
- Ensures quality

**Tier 2: The Managers (3 Agents)**
_[SCREEN: Manager agents]_

Three specialized managers:

1. **Portal Manager**
   - Oversees portal scanning
   - Manages authentication
   - Coordinates discoveries

2. **Proposal Manager**
   - Supervises proposal generation
   - Ensures quality
   - Manages submissions

3. **Research Manager**
   - Gathers market intelligence
   - Analyzes competitors
   - Finds historical data

**Tier 3: The Specialists (7 Agents)**
_[SCREEN: Specialist agents]_

Seven expert specialists:

1. **Portal Scanner** - Finds RFPs
2. **Portal Monitor** - Tracks changes
3. **Document Processor** - Analyzes files
4. **Content Generator** - Writes proposals
5. **Compliance Checker** - Verifies requirements
6. **Market Analyst** - Research pricing
7. **Historical Analyzer** - Learns from past bids

This division of labor enables parallel processing and expert-level performance!"

**[AGENT COORDINATION - 3:00-5:30]**

_[SCREEN: Agent activity monitor]_

"Let's watch the agents coordinate in real-time. Click 'Agent Monitor' in the admin menu.

_[SCREEN: Live activity feed]_

Here's a portal scan in progress:

**Coordination Flow:**

_[SCREEN: Event log]_

```
10:00:00 - Orchestrator receives: 'Scan Austin portal'
10:00:01 - Orchestrator → Portal Manager: 'Execute scan'
10:00:02 - Portal Manager → Portal Scanner: 'Scan for RFPs'
10:00:03 - Portal Manager → Portal Monitor: 'Check for updates'
```

**Parallel Execution:**

_[SCREEN: Parallel tasks visualization]_

Notice the agents work simultaneously:

- Scanner finding new RFPs
- Monitor checking existing ones
- Document Processor downloading files

This is 3x faster than sequential processing!

**Inter-Agent Communication:**

_[SCREEN: Communication graph]_

When Scanner finds an RFP:

```
Scanner → Portal Manager: 'Found IT RFP'
Portal Manager → Document Processor: 'Download docs'
Document Processor → Compliance Checker: 'Analyze reqs'
Compliance Checker → Proposal Manager: 'Requirements ready'
```

The agents pass context seamlessly, like a well-coordinated team."

**[WORKFLOW CREATION - 5:30-9:00]**

_[SCREEN: Workflows page]_

"Now let's create a custom workflow. Click 'Workflows' in the admin section.

_[SCREEN: Click 'New Workflow']_

**Workflow: Auto-Bid Pipeline**

_[SCREEN: Workflow builder]_

Let's build a workflow that automatically:

1. Discovers RFPs
2. Filters by criteria
3. Generates proposals
4. Routes for approval
5. Submits if approved

**Step 1: Discovery Trigger**

_[SCREEN: Add trigger]_

Trigger: 'New RFP Discovered'
Filter conditions:

- Category: Technology
- Value: >$100,000
- Match score: >80%

**Step 2: Document Processing**

_[SCREEN: Add action]_

Action: 'Process Documents'
Assign to: Document Processor
Options:

- Extract requirements
- Identify key dates
- Download all files

**Step 3: Proposal Generation**

_[SCREEN: Add action]_

Action: 'Generate Proposal'
Assign to: Proposal Manager
Options:

- Quality threshold: 90%
- Include pricing: Yes
- Auto-fill forms: Yes

**Step 4: Compliance Check**

_[SCREEN: Add action]_

Action: 'Verify Compliance'
Assign to: Compliance Checker
Options:

- Strictness: High
- Flag gaps: Yes
- Suggest fixes: Yes

**Step 5: Human Review**

_[SCREEN: Add decision node]_

Decision: 'Quality Gate'
If compliance score >95%:
→ Route to: 'Auto-approve'
Else:
→ Route to: 'Manual review'

**Step 6: Submission**

_[SCREEN: Add action]_

Action: 'Submit to Portal'
Assign to: Portal Manager
Options:

- Submit 24 hours before deadline
- Verify submission
- Archive confirmation

_[CLICK: Save Workflow]_

Perfect! This workflow now runs automatically for matching RFPs."

**[WORKFLOW MONITORING - 9:00-11:00]**

_[SCREEN: Active workflows dashboard]_

"Let's monitor workflows in action. Click 'Active Workflows.'

_[SCREEN: Workflow execution view]_

Here's our Auto-Bid Pipeline running:

**Current Execution:**
_[SCREEN: Progress visualization]_

✓ Step 1: RFP Discovered (Completed)

- Found: Cloud Infrastructure RFP
- Match score: 92%
- Triggered: 2 minutes ago

⟳ Step 2: Processing Documents (In Progress)

- Downloaded: 4/5 documents
- Extracted: 127 requirements
- ETA: 30 seconds

○ Step 3: Generate Proposal (Pending)
○ Step 4: Compliance Check (Pending)
○ Step 5: Human Review (Pending)
○ Step 6: Submit (Pending)

**Agent Assignments:**
_[SCREEN: Agent workload]_

- Document Processor: Active (this workflow)
- Proposal Manager: Idle
- Compliance Checker: Idle
- Portal Manager: Active (different workflow)

**Performance Metrics:**
_[SCREEN: Workflow stats]_

This workflow has:

- 15 successful executions
- 95% success rate
- Avg duration: 8 minutes
- Time saved: 60 hours (vs manual)"

**[PERFORMANCE OPTIMIZATION - 11:00-13:00]**

_[SCREEN: Agent performance dashboard]_

"Let's optimize agent performance. Click 'Agent Metrics.'

**Agent Efficiency:**

_[SCREEN: Performance charts]_

- **Portal Scanner**: 98% uptime, 2.3 RFPs/minute
- **Content Generator**: 92% quality score, 15 min/proposal
- **Compliance Checker**: 100% accuracy, 5 min/check

**Bottleneck Analysis:**

_[SCREEN: Bottleneck identification]_

The system identified:
⚠ Document Processor is at 80% capacity
✓ Consider adding another processor for peak times

**Optimization Recommendations:**

_[SCREEN: Recommendations panel]_

1. **Increase Portal Scanner concurrency**
   - Current: 2 concurrent scans
   - Recommended: 4 concurrent scans
   - Benefit: 2x faster discovery

2. **Enable proposal caching**
   - Cache similar sections
   - Reduce generation time by 40%

3. **Optimize document parsing**
   - Use OCR only when needed
   - Enable parallel processing
   - Speed improvement: 30%

_[SCREEN: Apply optimizations]_

Click 'Apply Recommended' to automatically optimize.

_[SCREEN: Optimization in progress]_

Done! The system is now 50% faster."

**[CUSTOM AGENT CREATION - 13:00-14:30]**

_[SCREEN: Advanced settings]_

"For advanced users, you can create custom specialist agents.

_[SCREEN: Create Agent form]_

Let's create a 'Government Relations Specialist' agent:

**Agent Configuration:**

Name: Government Relations Specialist
Tier: Specialist (Tier 3)
Parent Manager: Research Manager

**Capabilities:**

- Track agency contacts
- Monitor policy changes
- Analyze award history
- Identify decision makers

**Tools:**

- Web search
- Database queries
- Email extraction
- LinkedIn integration

**Behavior:**
_[SCREEN: Behavior settings]_

- Proactive: Check for updates daily
- Learning: Improve from feedback
- Coordination: Share findings with other agents

_[CLICK: Create Agent]_

_[SCREEN: Agent activated]_

Your custom agent is now part of the team!

You can assign it tasks in workflows or use it via the API."

**[WRAP UP - 14:30-15:00]**

"Excellent work! You now understand:
✓ The 3-tier agent architecture
✓ Agent coordination and communication
✓ Custom workflow creation
✓ Performance monitoring and optimization
✓ Custom agent creation

In our final video, we'll cover API integration for developers.

Subscribe and enable notifications for the complete series!"

**[END SCREEN]**

---

## Video 6: API Integration for Developers

**Duration:** 15-20 minutes
**Target Audience:** Developers, technical integrators

### Script

**[INTRO - 0:00-1:00]**

"Welcome developers! In this comprehensive tutorial, we'll integrate RFP Agent into your applications using our REST API.

Whether you're building a custom dashboard, integrating with existing systems, or creating mobile apps, this guide has you covered.

Topics we'll cover:

- API authentication
- Core endpoints and operations
- Real-time updates with SSE
- Webhook integration
- SDK usage
- Best practices

Let's build something amazing!"

**[API AUTHENTICATION - 1:00-3:00]**

_[SCREEN: API documentation page]_

"First, let's set up authentication. RFP Agent currently uses session-based auth, with JWT coming soon.

_[SCREEN: Code editor]_

**Session-Based Authentication:**

```javascript
// Login to create session
const response = await fetch('http://localhost:3000/api/auth/login', {
  method: 'POST',
  headers: { 'Content-Type': 'application/json' },
  credentials: 'include', // Important!
  body: JSON.stringify({
    username: 'your-username',
    password: 'your-password',
  }),
});

// Check response
if (response.ok) {
  console.log('Authenticated successfully');
  // Session cookie is now set
} else {
  console.error('Authentication failed');
}
```

**Making Authenticated Requests:**

```javascript
// All subsequent requests include session cookie
const rfps = await fetch('http://localhost:3000/api/rfps', {
  credentials: 'include', // Include session
});

const data = await rfps.json();
console.log(`Found ${data.total} RFPs`);
```

**API Key Authentication (Coming Soon):**

```javascript
// Future: JWT token authentication
const response = await fetch('http://localhost:3000/api/rfps', {
  headers: {
    Authorization: `Bearer ${YOUR_API_TOKEN}`,
  },
});
```

For production, we recommend API keys for better security."

**[CORE API OPERATIONS - 3:00-7:00]**

_[SCREEN: Split screen - docs and code]_

"Let's explore the core endpoints. I'll show you practical examples.

**1. List RFPs with Filtering:**

```javascript
async function getRFPs(filters = {}) {
  const params = new URLSearchParams({
    status: filters.status || 'discovered',
    page: filters.page || '1',
    limit: filters.limit || '20',
    ...filters,
  });

  const response = await fetch(`http://localhost:3000/api/rfps?${params}`, {
    credentials: 'include',
  });

  return response.json();
}

// Usage
const techRFPs = await getRFPs({
  status: 'discovered',
  category: 'technology',
  page: 1,
  limit: 50,
});

console.log(`Found ${techRFPs.total} tech RFPs`);
```

**2. Submit Manual RFP:**

```javascript
async function submitRFP(url, notes) {
  const response = await fetch('http://localhost:3000/api/rfps/manual', {
    method: 'POST',
    credentials: 'include',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      url,
      userNotes: notes,
    }),
  });

  if (!response.ok) {
    const error = await response.json();
    throw new Error(error.error);
  }

  return response.json();
}

// Usage
try {
  const result = await submitRFP(
    'https://portal.gov/rfp/123',
    'High priority RFP'
  );

  console.log('RFP submitted:', result.rfpId);
  console.log('Session ID:', result.sessionId);
} catch (error) {
  console.error('Submission failed:', error.message);
}
```

**3. Generate Proposal:**

```javascript
async function generateProposal(rfpId, companyProfileId, options = {}) {
  const response = await fetch(
    'http://localhost:3000/api/proposals/enhanced/generate',
    {
      method: 'POST',
      credentials: 'include',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        rfpId,
        companyProfileId,
        options: {
          generatePricing: true,
          generateCompliance: true,
          proposalType: 'technical',
          qualityThreshold: 0.85,
          ...options,
        },
      }),
    }
  );

  return response.json();
}

// Usage
const proposal = await generateProposal('rfp-id-123', 'company-profile-456');

console.log('Proposal generation started:', proposal.sessionId);
```

**4. Start Portal Scan:**

```javascript
async function startPortalScan(portalId, searchFilter = '') {
  const response = await fetch(
    `http://localhost:3000/api/portals/${portalId}/scan`,
    {
      method: 'POST',
      credentials: 'include',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ searchFilter }),
    }
  );

  if (response.status === 409) {
    throw new Error('Portal is already being scanned');
  }

  return response.json();
}

// Usage
const scan = await startPortalScan('austin-portal-id', 'cloud services');

console.log('Scan started:', scan.scanId);
```

These are your building blocks. Let's combine them!"

**[REAL-TIME UPDATES WITH SSE - 7:00-10:00]**

_[SCREEN: Code editor with SSE examples]_

"For real-time updates, we use Server-Sent Events. Here's how to implement them:

**Portal Scan Streaming:**

```javascript
function monitorPortalScan(portalId, scanId, callbacks) {
  const eventSource = new EventSource(
    `http://localhost:3000/api/portals/${portalId}/scan/stream?scanId=${scanId}`
  );

  eventSource.onopen = () => {
    callbacks.onConnect?.();
  };

  eventSource.onmessage = event => {
    const data = JSON.parse(event.data);

    switch (data.type) {
      case 'scan_started':
        callbacks.onStart?.(data);
        break;

      case 'step_update':
        callbacks.onProgress?.(data.step, data.progress);
        break;

      case 'rfp_discovered':
        callbacks.onRFPFound?.(data.rfp);
        break;

      case 'scan_completed':
        callbacks.onComplete?.(data.totalRfps);
        eventSource.close();
        break;

      case 'scan_failed':
        callbacks.onError?.(data.error);
        eventSource.close();
        break;
    }
  };

  eventSource.onerror = error => {
    callbacks.onError?.(error);
    eventSource.close();
  };

  // Return cleanup function
  return () => eventSource.close();
}

// Usage
const cleanup = monitorPortalScan('austin-portal-id', 'scan-123', {
  onConnect: () => console.log('Connected to scan stream'),

  onProgress: (step, progress) => {
    console.log(`${step}: ${progress}%`);
    updateProgressBar(progress);
  },

  onRFPFound: rfp => {
    console.log('New RFP:', rfp.title);
    addToList(rfp);
  },

  onComplete: total => {
    console.log(`Scan complete! Found ${total} RFPs`);
    showNotification(`Discovered ${total} new opportunities`);
  },

  onError: error => {
    console.error('Scan error:', error);
    showError(error.message);
  },
});

// Cleanup when component unmounts
// cleanup();
```

**Proposal Generation Streaming:**

```javascript
function monitorProposalGeneration(sessionId) {
  return new Promise((resolve, reject) => {
    const eventSource = new EventSource(
      `http://localhost:3000/api/proposals/submission-materials/stream/${sessionId}`
    );

    eventSource.onmessage = event => {
      const progress = JSON.parse(event.data);

      console.log(`${progress.currentStep}: ${progress.progress}%`);
      updateUI(progress);

      if (progress.status === 'completed') {
        eventSource.close();
        resolve(progress);
      } else if (progress.status === 'failed') {
        eventSource.close();
        reject(new Error(progress.error));
      }
    };

    eventSource.onerror = error => {
      eventSource.close();
      reject(error);
    };
  });
}

// Usage with async/await
try {
  const result = await monitorProposalGeneration('session-abc-123');
  console.log('Proposal generated!', result);
} catch (error) {
  console.error('Generation failed:', error);
}
```

SSE gives you real-time updates without polling!"

**[WEBHOOK INTEGRATION - 10:00-12:30]**

_[SCREEN: Webhook setup code]_

"Webhooks let you receive events in your application. Here's a complete implementation:

**1. Register Webhook:**

```javascript
async function registerWebhook(url, events, secret) {
  const response = await fetch('http://localhost:3000/api/webhooks', {
    method: 'POST',
    credentials: 'include',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      url,
      events,
      secret,
    }),
  });

  return response.json();
}

// Usage
const webhook = await registerWebhook(
  'https://your-app.com/webhooks/rfp-agent',
  [
    'rfp.discovered',
    'rfp.updated',
    'proposal.generated',
    'submission.completed',
  ],
  'your-secret-key'
);

console.log('Webhook registered:', webhook.id);
```

**2. Webhook Handler (Express):**

```javascript
import crypto from 'crypto';
import express from 'express';

const app = express();

function verifyWebhookSignature(payload, signature, secret) {
  const hmac = crypto.createHmac('sha256', secret);
  const digest = hmac.update(JSON.stringify(payload)).digest('hex');

  return crypto.timingSafeEqual(Buffer.from(signature), Buffer.from(digest));
}

app.post('/webhooks/rfp-agent', express.json(), async (req, res) => {
  const signature = req.headers['x-webhook-signature'];
  const secret = process.env.WEBHOOK_SECRET;

  // Verify signature
  if (!verifyWebhookSignature(req.body, signature, secret)) {
    return res.status(401).json({ error: 'Invalid signature' });
  }

  const { event, data, timestamp } = req.body;

  try {
    // Handle different events
    switch (event) {
      case 'rfp.discovered':
        await handleNewRFP(data.rfp);
        break;

      case 'proposal.generated':
        await handleProposalReady(data.proposal);
        break;

      case 'submission.completed':
        await handleSubmissionDone(data.submission);
        break;
    }

    res.status(200).json({ received: true });
  } catch (error) {
    console.error('Webhook error:', error);
    res.status(500).json({ error: 'Processing failed' });
  }
});

async function handleNewRFP(rfp) {
  console.log('New RFP discovered:', rfp.title);

  // Store in your database
  await db.rfps.create(rfp);

  // Notify your team
  await sendSlackNotification({
    channel: '#rfp-alerts',
    text: `New ${rfp.category} RFP: ${rfp.title}`,
    value: rfp.estimatedValue,
    deadline: rfp.deadline,
  });

  // Auto-generate if criteria met
  if (rfp.estimatedValue > 100000 && rfp.category === 'technology') {
    await generateProposal(rfp.id, 'company-profile-123');
  }
}

app.listen(3001, () => {
  console.log('Webhook handler listening on port 3001');
});
```

Webhooks are perfect for event-driven architectures!"

**[ERROR HANDLING - 12:30-14:00]**

_[SCREEN: Error handling patterns]_

"Robust error handling is crucial. Here's a production-ready approach:

**1. Retry with Exponential Backoff:**

```javascript
async function fetchWithRetry(url, options, maxRetries = 3) {
  for (let i = 0; i < maxRetries; i++) {
    try {
      const response = await fetch(url, options);

      if (response.ok) {
        return response;
      }

      // Don't retry client errors (4xx)
      if (response.status >= 400 && response.status < 500) {
        const error = await response.json();
        throw new Error(error.error);
      }

      // Server errors (5xx) - retry with backoff
      if (i < maxRetries - 1) {
        const delay = Math.pow(2, i) * 1000; // 1s, 2s, 4s
        console.log(`Retry ${i + 1} after ${delay}ms...`);
        await new Promise(resolve => setTimeout(resolve, delay));
        continue;
      }

      throw new Error(`Request failed: ${response.status}`);
    } catch (error) {
      if (i === maxRetries - 1) throw error;
    }
  }
}

// Usage
try {
  const response = await fetchWithRetry('http://localhost:3000/api/rfps', {
    credentials: 'include',
  });
  const data = await response.json();
} catch (error) {
  console.error('Failed after retries:', error);
}
```

**2. Rate Limit Handling:**

```javascript
async function handleRateLimits(url, options) {
  const response = await fetch(url, options);

  if (response.status === 429) {
    const resetTime = response.headers.get('X-RateLimit-Reset');
    const waitTime = parseInt(resetTime) * 1000 - Date.now();

    console.log(`Rate limited. Waiting ${waitTime}ms...`);
    await new Promise(resolve => setTimeout(resolve, waitTime));

    // Retry after waiting
    return fetch(url, options);
  }

  return response;
}
```

**3. Comprehensive Error Handler:**

```javascript
class RFPAgentError extends Error {
  constructor(message, statusCode, details) {
    super(message);
    this.statusCode = statusCode;
    this.details = details;
  }
}

async function safeAPICall(url, options) {
  try {
    const response = await handleRateLimits(url, options);

    if (!response.ok) {
      const error = await response.json();

      throw new RFPAgentError(
        error.error || 'Request failed',
        response.status,
        error.details
      );
    }

    return response.json();
  } catch (error) {
    if (error instanceof RFPAgentError) {
      // Handle known API errors
      console.error(`API Error ${error.statusCode}:`, error.message);

      if (error.details) {
        console.error('Details:', error.details);
      }
    } else if (error instanceof TypeError) {
      // Network error
      console.error('Network error:', error.message);
    } else {
      // Unknown error
      console.error('Unexpected error:', error);
    }

    throw error;
  }
}
```

Always handle errors gracefully in production!"

**[COMPLETE INTEGRATION EXAMPLE - 14:00-17:00]**

_[SCREEN: Full application code]_

"Let's build a complete integration - an RFP dashboard.

**RFP Dashboard Application:**

```javascript
class RFPDashboard {
  constructor(apiUrl) {
    this.apiUrl = apiUrl;
    this.eventSources = [];
  }

  // Initialize dashboard
  async init() {
    // Authenticate
    await this.login('user@example.com', 'password');

    // Load initial data
    await this.loadRFPs();
    await this.loadPortals();

    // Set up real-time updates
    this.subscribeToUpdates();

    // Start monitoring
    this.startMonitoring();
  }

  // Authentication
  async login(username, password) {
    const response = await fetch(`${this.apiUrl}/api/auth/login`, {
      method: 'POST',
      credentials: 'include',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ username, password }),
    });

    if (!response.ok) {
      throw new Error('Authentication failed');
    }

    console.log('Authenticated successfully');
  }

  // Load RFPs
  async loadRFPs(filters = {}) {
    const params = new URLSearchParams(filters);
    const response = await safeAPICall(`${this.apiUrl}/api/rfps?${params}`, {
      credentials: 'include',
    });

    this.displayRFPs(response.rfps);
    return response;
  }

  // Load portals
  async loadPortals() {
    const portals = await safeAPICall(`${this.apiUrl}/api/portals`, {
      credentials: 'include',
    });

    this.displayPortals(portals);
    return portals;
  }

  // Start portal scan
  async scanPortal(portalId) {
    try {
      const result = await safeAPICall(
        `${this.apiUrl}/api/portals/${portalId}/scan`,
        {
          method: 'POST',
          credentials: 'include',
        }
      );

      // Monitor scan progress
      this.monitorScan(portalId, result.scanId);

      return result;
    } catch (error) {
      if (error.statusCode === 409) {
        alert('Portal scan already in progress');
      } else {
        alert(`Scan failed: ${error.message}`);
      }
    }
  }

  // Monitor scan with SSE
  monitorScan(portalId, scanId) {
    const eventSource = new EventSource(
      `${this.apiUrl}/api/portals/${portalId}/scan/stream?scanId=${scanId}`
    );

    this.eventSources.push(eventSource);

    eventSource.onmessage = event => {
      const data = JSON.parse(event.data);

      switch (data.type) {
        case 'scan_started':
          this.showNotification(`Scan started: ${data.portalName}`);
          break;

        case 'step_update':
          this.updateScanProgress(scanId, data.step, data.progress);
          break;

        case 'rfp_discovered':
          this.addRFPToList(data.rfp);
          break;

        case 'scan_completed':
          this.showNotification(`Scan complete! Found ${data.totalRfps} RFPs`);
          this.loadRFPs(); // Refresh list
          eventSource.close();
          break;
      }
    };
  }

  // Generate proposal
  async generateProposal(rfpId) {
    try {
      const result = await safeAPICall(
        `${this.apiUrl}/api/proposals/enhanced/generate`,
        {
          method: 'POST',
          credentials: 'include',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({
            rfpId,
            companyProfileId: 'your-company-id',
            options: {
              generatePricing: true,
              generateCompliance: true,
              proposalType: 'technical',
            },
          }),
        }
      );

      // Monitor generation
      this.monitorProposalGeneration(result.sessionId);

      return result;
    } catch (error) {
      alert(`Proposal generation failed: ${error.message}`);
    }
  }

  // Monitor proposal generation
  async monitorProposalGeneration(sessionId) {
    const eventSource = new EventSource(
      `${this.apiUrl}/api/proposals/submission-materials/stream/${sessionId}`
    );

    this.eventSources.push(eventSource);

    eventSource.onmessage = event => {
      const progress = JSON.parse(event.data);

      this.updateProposalProgress(
        sessionId,
        progress.currentStep,
        progress.progress
      );

      if (progress.status === 'completed') {
        this.showNotification('Proposal generated successfully!');
        this.loadRFPs(); // Refresh to show new proposal
        eventSource.close();
      } else if (progress.status === 'failed') {
        alert(`Proposal generation failed: ${progress.error}`);
        eventSource.close();
      }
    };
  }

  // Subscribe to webhook events
  async subscribeToUpdates() {
    // Register webhook
    await safeAPICall(`${this.apiUrl}/api/webhooks`, {
      method: 'POST',
      credentials: 'include',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        url: 'https://your-app.com/webhooks/rfp-agent',
        events: [
          'rfp.discovered',
          'proposal.generated',
          'submission.completed',
        ],
        secret: 'your-webhook-secret',
      }),
    });
  }

  // Monitoring loop
  startMonitoring() {
    setInterval(async () => {
      // Check for new RFPs
      const rfps = await this.loadRFPs({
        status: 'discovered',
        limit: 5,
      });

      // Auto-generate for high-value RFPs
      for (const rfp of rfps.rfps) {
        if (parseFloat(rfp.estimatedValue) > 200000) {
          await this.generateProposal(rfp.id);
        }
      }
    }, 300000); // Every 5 minutes
  }

  // UI update methods
  displayRFPs(rfps) {
    const container = document.getElementById('rfp-list');
    container.innerHTML = rfps
      .map(
        rfp => `
      <div class="rfp-card">
        <h3>${rfp.title}</h3>
        <p>${rfp.agency}</p>
        <span>$${parseFloat(rfp.estimatedValue).toLocaleString()}</span>
        <button onclick="dashboard.generateProposal('${rfp.id}')">
          Generate Proposal
        </button>
      </div>
    `
      )
      .join('');
  }

  displayPortals(portals) {
    // Similar implementation
  }

  updateScanProgress(scanId, step, progress) {
    const progressBar = document.getElementById(`scan-${scanId}`);
    if (progressBar) {
      progressBar.style.width = `${progress}%`;
      progressBar.textContent = `${step}: ${progress}%`;
    }
  }

  updateProposalProgress(sessionId, step, progress) {
    // Similar implementation
  }

  showNotification(message) {
    // Show toast notification
    console.log('Notification:', message);
  }

  addRFPToList(rfp) {
    // Add to existing list
    console.log('New RFP:', rfp);
  }

  // Cleanup
  destroy() {
    // Close all SSE connections
    this.eventSources.forEach(source => source.close());
    this.eventSources = [];
  }
}

// Initialize dashboard
const dashboard = new RFPDashboard('http://localhost:3000');
dashboard.init().catch(console.error);
```

This is a complete, production-ready integration!"

**[BEST PRACTICES - 17:00-18:30]**

_[SCREEN: Best practices checklist]_

"Before we wrap up, here are essential best practices:

**1. Use Environment Variables:**

```javascript
const API_URL = process.env.REACT_APP_API_URL || 'http://localhost:3000';
const API_KEY = process.env.REACT_APP_API_KEY;
```

**2. Implement Request Queueing:**

```javascript
class RequestQueue {
  constructor(maxConcurrent = 5) {
    this.maxConcurrent = maxConcurrent;
    this.queue = [];
    this.active = 0;
  }

  async add(request) {
    if (this.active >= this.maxConcurrent) {
      await new Promise(resolve => this.queue.push(resolve));
    }

    this.active++;

    try {
      return await request();
    } finally {
      this.active--;
      const next = this.queue.shift();
      if (next) next();
    }
  }
}

const queue = new RequestQueue(5);
const response = await queue.add(() => fetch('/api/rfps'));
```

**3. Cache Responses:**

```javascript
class APICache {
  constructor(ttl = 60000) {
    this.cache = new Map();
    this.ttl = ttl;
  }

  async get(key, fetcher) {
    const cached = this.cache.get(key);

    if (cached && Date.now() - cached.timestamp < this.ttl) {
      return cached.data;
    }

    const data = await fetcher();
    this.cache.set(key, {
      data,
      timestamp: Date.now(),
    });

    return data;
  }
}

const cache = new APICache(60000); // 1 minute TTL
const rfps = await cache.get('rfps:discovered', () =>
  fetch('/api/rfps?status=discovered').then(r => r.json())
);
```

**4. Monitor Performance:**

```javascript
function trackAPICall(name, fn) {
  const start = performance.now();

  return fn().then(
    result => {
      const duration = performance.now() - start;
      console.log(`${name}: ${duration.toFixed(2)}ms`);

      // Send to analytics
      analytics.track('API Call', {
        name,
        duration,
        success: true,
      });

      return result;
    },
    error => {
      const duration = performance.now() - start;
      console.error(`${name} failed: ${duration.toFixed(2)}ms`, error);

      analytics.track('API Call', {
        name,
        duration,
        success: false,
        error: error.message,
      });

      throw error;
    }
  );
}

const rfps = await trackAPICall('getRFPs', () =>
  fetch('/api/rfps').then(r => r.json())
);
```

**5. Graceful Degradation:**

```javascript
async function getRFPsWithFallback() {
  try {
    // Try API first
    const response = await fetch('/api/rfps');
    return await response.json();
  } catch (error) {
    console.warn('API unavailable, using local cache');

    // Fallback to local storage
    const cached = localStorage.getItem('cached_rfps');
    return cached ? JSON.parse(cached) : { rfps: [], total: 0 };
  }
}
```

These practices ensure robust, performant integrations!"

**[WRAP UP - 18:30-19:00]**

"Congratulations! You've completed the RFP Agent developer guide. You now know how to:

✓ Authenticate with the API
✓ Use all core endpoints
✓ Implement real-time updates with SSE
✓ Handle webhooks for event-driven architecture
✓ Build robust error handling
✓ Create production-ready integrations

**Resources:**

- 📚 Full API docs: <https://docs.rfpagent.com/api>
- 💻 Code examples: <https://github.com/VerticalLabs-ai/rfpagent>
- 🤝 Community: <https://rfpagent.slack.com>
- 📧 Support: <developers@rfpagent.com>

Thank you for watching this complete tutorial series! Happy coding, and may your integrations be bug-free!

Don't forget to subscribe for more tutorials and updates!"

**[END SCREEN - 19:00]**

---

## Production Notes

### Equipment Recommendations

**Video:**

- Camera: 1080p minimum, 4K preferred
- Lighting: Soft box lighting for face, ring light for screen
- Screen recording: OBS Studio or Camtasia

**Audio:**

- Microphone: USB condenser mic (Blue Yeti, Rode NT-USB)
- Room treatment: Minimize echo with acoustic panels
- Audio software: Audacity for editing

### Recording Tips

1. **Screen Recording:**
   - Use 1920x1080 resolution
   - 30 FPS minimum
   - Zoom in on important UI elements
   - Use cursor highlighting

2. **Pacing:**
   - Speak clearly and slowly
   - Pause between major sections
   - Repeat important points
   - Allow time for viewers to follow along

3. **Editing:**
   - Cut out mistakes and long pauses
   - Add transitions between sections
   - Include chapter markers
   - Add captions for accessibility

4. **Graphics:**
   - Use branded intro/outro
   - Add lower thirds with section names
   - Include code syntax highlighting
   - Create animated diagrams for architecture

### Distribution

- **YouTube:** Primary platform with full series playlist
- **Website:** Embed videos in documentation
- **Social Media:** Share clips and highlights
- **Email:** Send series to users

### Follow-up Content

Create supplementary materials:

- Written transcripts for each video
- Downloadable code samples
- Interactive playground for testing
- FAQ based on viewer questions
